
\begin{tad}{\tadNombre{PokemonGo}}
\tadGeneros{pgo}

\tadIgualdadObservacionalSimple{$(true \igobs true) \land (false \igobs false) \land \neg(true \igobs false) \land \neg(false \igobs true)$}
%\tadAlinearFunciones{pertenecePokemon}{kg, pokemon/p}{conj(jugador)}

\tadObservadores
\tadOperacion{mapa}{pgo}{mapa}{}
\tadOperacion{jugadores}{pgo}{conj(jugador)}{}
\tadOperacion{pokenodos}{pgo}{conj(pknodo)}{}

\tadGeneradores

\tadOperacion{crearPGO}{mapa}{pgo}{}
\tadOperacion{agPknodo}{pgo/$pg$, pknodo/$nodo$}{pgo}{$nodo \in$ pokenodos($pg$)}
\tadOperacion{agJugador}{pgo/$pg$, jugador/$j$}{pgo}{$j \in$ jugadores($pg$)}

\tadOtrasOperaciones

% PARA HACER:
% Es importante agregar todas las restricciones !!!

% PARA HACER:
% Ver lo de restringir jugadores usando nombre

% PARA HACER:
% Ver si queremos restringir eliminados, o si hacer un if para ver si esta eliminado, en ese caso no hacer nada

% PARA HACER:
% Indices de captura y funciones cuentapokemones

\tadOperacion{moverJugador}{pgo,jugador,coordenada}{pgo}{}
\tadOperacion{conectarJug}{pgo, jugador}{pgo}{}
\tadOperacion{desconectarJug}{pgo, jugador}{pgo}{} $\newline $

\tadOperacion{movimientoValido}{map, coordenada, coordenada}{bool}{}
\tadOperacion{distanciaMenorA}{nat, coordenada, coordenada}{bool}{}

\tadOperacion{jugadoresEnRango}{pgo, pknodo}{conj(jugador)}{}
\tadOperacion{pknodosCapturables}{pgo}{conj(pknodo)}{}
\tadOperacion{elegirCapturador}{pgo}{pknodo}{}
\tadOperacion{manejarCapturas}{pgo, jugador}{pgo}{}
\tadOperacion{aplicarSancion}{pgo,jugador/j}{pgo}{} $\newline $

\tadOperacion{actualizarPknodos}{pgo,jugador/j}{pgo}{}
\tadOperacion{realizaCapturas}{pgo}{pgo}{}
\tadOperacion{capturarPorNodo}{pgo,conj(pknodo)}{pgo}{}
\tadOperacion{eliminarPokenodos}{pgo}{pgo}{}
\tadOperacion{jugElegido}{pgo, pknodo}{jugador}{}



% PARA HACER:
% Hay que diferenciar el nombre del tipo pgo con el nombre de variable pgo
% variable -> pgo     tipo -> pGO   (la idea es que la variable sea mas facil de escribir)
\tadAxiomas[\paratodo{pGo}{pgo}]

%\tadAlinearAxiomas{}

% Mapa (pgo)
$ $\newline
\tadAxioma{mapa(crearPGO($map$))}{$map$}
\tadAxioma{mapa(agJugador($pgo$, $j$))}{mapa($pgo$)}
\tadAxioma{mapa(agPknodo($pgo$, $pknodo$))}{mapa($pgo$)}

% Jugadores (pgo)
$ $\newline
\tadAxioma{jugadores(crearPGO($mapa$))}{$\emptyset$}
\tadAxioma{jugadores(agJugador($pgo$, $j$))}{Ag($j$, jugadores($pgo$))}
\tadAxioma{jugadores(agPknodo($pgo$, $pknodo$))}{jugadores($pgo$)}


% Pokenodos (pgo)
$ $\newline
\tadAxioma{pokenodos(crearPGO($mapa$))}{$\emptyset$}
\tadAxioma{pokenodos(agJugador($pgo$, $j$))}{pokenodos($pgo$)}
\tadAxioma{pokenodos(agPknodo($pgo$, $pknodo$))}{Ag($pknodo$, pokenodos($pgo$))}



% Mover jugador (pgo, j, pos)
%mover(j) es el generador de jugador
$ $\newline
\tadAxioma{moverJugador($pgo$, $j$, $npos$)}
{\IF movimientoValido(mapa($pgo$), posicion($j$), $npos$)  THEN 
manejarCapturas($pgo$, mover($j$, $npos$))
ELSE 
aplicarSancion($pgo$, $j$) 
FI
}

% MovimientoValido(mapa, pos1, pos2)
$ $\newline
\tadAxioma{movimientoValido($map$, $pos1$, $pos2$)}
{distanciaMenorA10($pos1$, $pos2$) $\land$ existeCoor($map$, $pos1$) $\land$ existeCoor($map$, $pos2$)
$\yluego$ hayCamino($map$, $pos1$, $pos2$)}


% DistanciaMenorA
$ $\newline
\tadAxioma{distanciaMenorA($n$, $c1$, $c2$)}
{($\Pi_2(c1) - \Pi_1(c1)) * (\Pi_2(c1) - \Pi_1(c1)$)  $+$ $ $\newline
($\Pi_2(c2) - \Pi_1(c2)) * (\Pi_2(c2) - \Pi_1(c2)$)  $\leq$ $n * n$}

% ManejarCapturas (pgo, nuevoJug)
$ $\newline
\tadAxioma{manejarCapturas($pgo$, $nJ$)}
{eliminarPknodos(realizarCapturas(actualizarPknodos($pgo$, $nJ$)))}


% AplicarSancion (pgo, jug)
$ $\newline
\tadAxioma{aplicarSancion(crearPGO($mapa$),$j$)}{crearPGO($mapa$)}
\tadAxioma{aplicarSancion(agPknodo($pgo$, $pkNodo$),$j$)}{agPknodo(aplicarSancion($pgo$, $j$), $pkNodo$)}
\tadAxioma{aplicarSancion(agJugador($pgo$, $j$),$j'$)}{
\IF $j = j'$
THEN
agJugador($pgo$, sancionar($j$)) 
ELSE 
agJugador(aplicarSancion($pgo$, $j'$), $j$)
FI
}

% ActualizarPokenodos (pgo, jug)  = actualizarPknodos
$ $\newline
\tadAxioma{actualizarPknodos(crearPGO($mapa$), $nJ$)}{crearPGO($mapa$)}  %ver espaciado raro por aca
\tadAxioma{actualizarPknodos(agJugador($pgo$, $j$), $nJ$)}{agJugador(actualizarPknodos($pgo$,$nJ$), $j$)}
\tadAxioma{actualizarPknodos(agPknodo($pgo$, $pknodo$), $nJ$)}{
\IF enRango2($pknodo$, posicion($nJ$))
THEN
agPknodo(actualizarPknodos($pgo$,$nJ$), reiniciar($pknodo$))
ELSE 
agPknodo(actualizarPknodos($pgo$,$nJ$), sumarUno($pknodo$))
FI
}


% PknodosCapturables (pgo)
$ $\newline
\tadAxioma{pknodosCapturables(crearPGO($mapa$))}{$\emptyset$}
\tadAxioma{pknodosCapturables(agJugador($pgo$, $j$))}{pknodosCapturables($pgo$)}
\tadAxioma{pknodosCapturables(agPknodo($pgo$, $pknodo$))}{
\IF contador($pknodo$) = 10
THEN
Ag($pknodo$, pknodosCapturables($pgo$))
ELSE 
pknodosCapturables($pgo$)
FI
}


% JugadoresEnRango (pgo, pknodo)
$ $\newline
\tadAxioma{jugadoresEnRango(crearPGO($mapa$), $pknodo$)}{$\emptyset$}
\tadAxioma{jugadoresEnRango(agPknodo($pgo$, $pknodo$), $pknodo'$)}{jugadoresEnRango($pgo$, $pknodo'$)}
\tadAxioma{jugadoresEnRango(agJugador($pgo$, $j$), $pknodo$)}{
\IF conectado($j$) AND  enRango2($pknodo$, $j$)
THEN
Ag($j$, jugadoresEnRango($pgo$, $pknodo$))
ELSE 
jugadoresEnRango($pgo$, $pknodo$)
FI}


% JugElegido (pgo, pknodo)
$ $\newline
\tadAxioma{jugElegido($pgo$, $pknodo$)}{dameUno(jugadoresEnRango($pgo$, $pknodo$))}


% RealizaCapturas (pgo)
$ $\newline
\tadAxioma{realizarCapturas($pgo$)}{capturasPorNodo($pgo$, nodosCapturables($pgo$))}


% CapturasPorNodo (pgo, pknodosRestantes)
$ $\newline
\tadAxioma{capturarPorNodo($pgo$, $pknodos$)}{
\IF $pknodos = \emptyset$
THEN
$pgo$
ELSE 
capturarPorNodo(capturar($pgo$, jugElegido($pgo$,dameUno($pknodos$)), pokemon(dameUno($pknodos$))), sinUno($pknodos$))
FI}

% EliminarNodos (pgo)
$ $\newline
\tadAxioma{eliminarNodos(crearPGO($mapa$))}{crear($mapa$)}
\tadAxioma{eliminarNodos(agJugador($pgo$, $j$))}{agJugador(eliminarNodos($pgo$), $j$)}
\tadAxioma{eliminarNodos(agPknodo($pgo$, $pknodo$))}{
\IF contador($pknodo$) $\geq 10$
THEN
eliminarNodos($pgo$)
ELSE 
agNodo(eliminarNodos($pgo$), $pnodo$)
FI
}



\end{tad}